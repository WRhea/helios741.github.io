# 计算机网络篇

## 每一层对应的功能
1. 物理层：通过媒介传输比特，确定机械及电气规范(bit)
2. 数据链路层：将bit组装成帧，实现点到点的传递(帧Frame)
3. 网络层：负责将数据包从源到目的的传递和网际互联(包packet)
4. 传输层：提供端到端的可靠报文传递和错误恢复(端segment)
5. 会话层：建立，管理和终止会话(会话协议数据单元SPDU)
6. 表示层：对数据进行翻译，加密和压缩(表示协议数据单元PPDU)
7. 应用层：允许访问OSI环境的手段(应用协议数据单元APDU)

## HTTP 协议

规范把HTTP请求分为三部分：`状态行`,`请求头`,`消息主体`

### http请求头有哪些字段
|协议头字段名|说明|实例|
|:--:|:---:|:---:|
|Accept|	能够接受的回应内容类型（Content-Types）|Accept: text/plain|
|Accept-Charset|	能够接受的字符集|Accept-Charset: utf-8|
|Accept-Encoding|	能够接受的编码方式列表|	Accept-Encoding: gzip, deflate|
|Accept-Language|能够接受的回应内容的自然语言列表|Accept-Language: en-US|
|Accept-Datetime|能够接受的按照时间来表示的版本|Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT|
|Cache-Control|	用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令|Cache-Control: no-cache|
|Connection|该浏览器想要优先使用的连接类型|Connection: keep-alive|
|Cookie|之前由服务器通过 Set- Cookie）发送的一个 超文本传输协议Cookie|	Cookie: $Version=1; Skin=new|
|Content-Type|请求的类型|text/plain|


### 常见状态码
|Type|Reason-phrase|Note|
| :-------- | :--------:| :--: |
|1XX|Informational|信息性状态码，表示接受的请求正在处理|
|2XX|Success|成功状态码，表示请求正常处理完毕|
|3XX|Redirection|重定向状态码，表示需要客户端需要进行附加操作|
|4XX|Client Error|客户端错误状态码，表示服务器无法处理请求|
|5XX|Server Error|服务器错误状态码，表示服务器处理请求出错|

下面是几个重要的状态码：
- `301/302`(重定向)请求的URL已经移走，应答中包含一个`Location URL`,说明你请求的资源现在的位置
- `304`(未修改) 客户端的缓存资源是最新的，要客户端使用缓存

### 304是什么意思？有没有方法不请求不经过服务器直接使用缓存
- 304(未修改) 自从上次请求后，请求的网页未修改过。服务器返回相应的时候,不会放回网页的内容
- 设置`Cache-Control`和`Expires`等缓存


## 浏览器怎么知道与服务器连接是否断开
通过keep-live的时间

### http常用的方法有哪些
1. GET：用于访问已经被URI(统一资源标识符)，可以通过URL传递给服务器
2. POST：用于传输信息给服务器
3. PUT：传输文件，报文主体包含文件内容，保存在URI的位置
4. HEAD：获取报文头部，与`GET`方式类似，但是不反悔报文的主体，一般用于验证`URI`是否有效
5. DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件
6. OPTIONS：查询URI支持的HTTP方法

*GET方法和POST方法的区别：*
1. GET重点时从服务器获取资源，POST重点是向服务器发送资源
2. GET是通过URL发送的，是用户可见的，POST将键值对封存在请求的实体中，发送给服务器，用户是不可见的
3. GET传输的数据量小但是效率高，POST数据量大适合上传文件图片等
4. POST比GET安全

### http 1.0，1.1，2.0的区别

影响网络请求的两个因素：`带宽`，`延迟`

#### http1.1对1.0的改进
|类型|http2.0|http 1.1|
| :-------- | :--------:| :--: |
|连接复用|能持续性连接(keep-live)|连接无法复用|
|缓存|增加了Cache-Control头域(max-age指令支持相对时间戳；private和no-store指令禁止对象被缓存；no-transform阻止Proxy进行任何改变响应的行为)|，If-Modified-Since头域使用的是绝对时间戳，精确到秒，但使用绝对时间会带来不同机器上的时钟同步问题|
|增加了字段|增加了Host字段，WEB浏览器可是通过主机头名来识别是那个服务器，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。|无|

*简述新特性*
1. 默认持久性连接
2. 管线化：客户端可以发送多个HTTP请求，不用一个个等待相应

*什么是管线化？*
将多个HTTP请求整批提交的技术，在传送过程中无语等待服务器的回应。传统的请求是这样的`请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3`使用管线化就变成这样了`请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3`.
**注意下面几点**
1. 只有GET和HEAD请求支持管线化，而POST有所限制
2. 首次创建连接不会启动管线机制，因为服务器不一定支持`HTTP/1.1`版本的协议
3. 管线化不会改变相应的顺序
4. 

*使用长连接之后怎么客户端和服务端怎么知道本次传输结束了呢？*
1. 判断传输的数据是否达到了`Content-length`指定的大小
2. (动态生成的文件没有`Content-length`)分块传输的(chunked)这时候要根据`chunked`编码来判断，`chunked`编码的数据最后有一个空的`chunked`块，能够表明这次传输结束了



#### http2.0对1.1的改进
|类型|http1.1|http 2.0|
| :-------- | :--------:| :--: |
|多路复用|多路复用允许通过单一的http的2.0连接发送多重的请求-响应信息|客户端在同一个时间，请对同一个域名下的请求数量是有限制，超过数量的请求是会被阻塞的|
|二进制分帧|在应用层(http/2)和传输层之间增加了二进制分帧层，在二进制分帧里面，HTTP/2会把所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式的编码|HTTP首部会封装到头部当中，数据信息会放在body中|
|性能方面的优化|HTTP/2通过让所有的数据流共用同一个连接，可以更高效的使用TCP连接，让高宽带服务于HTTP服务|性能优化不是在高宽带而是在低延迟，起初会限制最大速度，如果成功会增加(TCP的慢启动)，但是由于这种原因，让原本就具有突发性和短时性的HTTP连接变得十分低效|
|首部压缩|支持首部压缩使用的是HPACK算法|不支持首部压缩|
|服务器推送|在客户端请求之前发送数据的机制(服务端无需通知客户端，想客户端推送想要的文件)，但是还是有一些缺点比如说何时去push，浏览器也可以主动取消push|不支持服务器推送|

1. 不同浏览器对http请求数量的限制
![](https://pic2.zhimg.com/faedeb3dae59455f6520d6a5dbf436e5_b.png)
这也就是为什么一个站点会有多个静态资源的CDN域名，目的就是为了解决**浏览器针对同一个域名请求限制阻塞的问题**，而HTTP/2则允许通过单一的HTTP/2连接发送多重的*请求-响应*消息。
![](https://pic2.zhimg.com/b1e608ddb7493608efea3e76912aabe1_b.png)
因此HTTP/2很容易去实现多流并行而不用依赖多个TCP连接，HTTP/2把HTTP协议通信的基本单位缩小为一个个帧，这些帧对应着逻辑中的消息，并行的在同一个TCP连接上双向交换信息。
2. 二进制分帧
在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层
![](https://pic4.zhimg.com/906e22193e61cd561325d93aae0f1e07_b.jpg)
HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。
	* 单连接多资源的方式，减少服务器端的连接压力，内存占用更少，连接吞吐量更大
	* 由于TCP的连接减少而使网络拥塞状况得到改善，同时慢启动的时间减少，是阻塞和丢包回复速度更快

![](https://pic2.zhimg.com/ae5418b7da1c6593fd6addad0310faa5_b.png)

### HTTP缓存机制

#### 为什么需要缓存
缓存为了解决下面的几个问题：
1. 冗余的数据传输：节约网络费用
2. 带宽瓶颈：降低传输延时
3. 瞬间阻塞：对于一些突发的事件，降低了对服务器的要求，避免了网络崩溃
4. 距离延时：降低了传播延时

#### 缓存结构
缓存分为下面两种：
1. 私有缓存：浏览器的临时文件
2. 共有缓存：特殊的代理服务器

#### 缓存控制策略
服务器通过`Cache-Control`和`Expires`首部来控制客户端的缓存策略
1. `no-Store`: 不允许存储本地缓存文件，每次从服务器下载
2. `no-Cache`: 允许存储缓存，但是每次都必须与原是服务器进行再验证
3. `max-age`: 表示新鲜度维持时间，=0类似于no-Cache
4. `Expires`: 依赖于服务器时间，不推荐使用
5. `must-revalidate`: 有些缓存允许返回过期资源副本，设置该头部后，缓存只允许提供新鲜的副本，过期副本必须验证

#### 客户端新鲜度的控制

客户端也可以通过`Cache-Control`请求来强化或者放松对过期时间的限制
1. `Cache-Control: max-stale (=<s>)` 缓存可以提供过期文件，如果有参数s，最多过期s时间
2. `Cache-Control: min-fresh = <s>` 缓存在未来s秒内要保持新鲜
3. `Cache-Control: max-age = <s>` 缓存无法返回缓存时间大于s的资源
4. `no-Cache` or `no-Store` 必须再验证 or 必须尽快删除存储
5. `only-if-cached` 只有缓存存在副本，才获取一份副本



### HTTPS和HTTP的缺点

#### HTTP的缺点
1. 通信明文不加密，内容可能被窃听
2. 不验证通信双方的身份，可能遭到伪装
3. 无法验证报文的完整性

#### HTTPS
HTTPS完美解决了HTTP的缺点：
*HTTPS = HTTP加密处理(SSL安全通信线路) + 认证(数字证书) + 完整性保护(hash算法)*

HTTPS缺省工作在TCP协议的443端口，他的工作流程如下：
1. 完成TCP三次同步握手
2. 客户端验证服务器的数字证书
3. DH算法协商对称加密算法的密钥，hash算法的密钥
4. SSL安全加密隧道协商完成
5. 网页以加密的方式传输，用协商的对称加密加密算法和密钥算法，保证数据的机密性；用协商的hash算法进行数据完整性的保护，保证数据不被篡改.


### cookie和session的机制是什么
会话(session)是跟踪web程序中常用的技术，用来跟踪用户的整个会话，也可以弥补http协议无状态的不足。
cookie是在客户端记录信息确定用户的身份；
session是在服务器端记录信息确认用户的身份。

#### 会话跟踪的常用方式

1. URL重写：早`URL`的尾部添加一个附加数据以表示该会话，把该会话ID通过URL的信息传递过去，以便在服务器识别不同的用户
2. 隐藏表单域： 将会话ID添加到HTML表单元素中提交到服务器，此表单并不在客户端显示
3. cookie：客户端有两种方式保存cookie这个对象(cookie是可以被禁用的
	i. 保存在客户端的内存中，被称为临时cookie,浏览器关闭这个对象消失
	ii. 保存在客户端的磁盘上，以后只要客户端访问该网站，就会将这个服务器发送到服务器，前提是这个cookie没有过期
4. session：在服务器创建一个session对象，通过这个对象的键值对来识别一个用户。session是依赖cookie的，如果禁用了cookie那么session也会失效

### HTTP补充
输入域名(url)-->DNS映射为IP-->TCP三次握手-->HTTP请求-->HTTP响应-->(浏览器跟踪重定向地址)-->服务器处理请求-->服务器返回一个html响应-->(视情况决定释放TCP连接)-->客户端解析HTML-->获取嵌入在HTML中的对象重新发起http请求

## TCP协议

### 字段
![](http://img.blog.csdn.net/20131019111917546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2lsc29ucGVuZzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### TCP的特性
1. 面向连接，可靠的字节流服务
2. 在一个TCP连接中，仅有双方进行彼此通信，广播和多播不能用于TCP
3. TCP使用校验和，确认和重传机制来保证可靠传输
4. 使用累积确认
5. TCP使用滑动窗口来实现流量控制，通过动态改变窗口大小进行拥塞控制

### 三次握手

1. 第一次握手：一般由客户端发起(SYN=1,seq=x)
	客户端发送一个TCP的SYN标志为1的包，指明客户端打算连接的服务器的端口，以及初始化序列号为x，保存在包头的序列号字段中。
	**发送完毕后客户端进入SYN_SEND状态**
2. 第二次握手：服务器会送确认(ACK)包(SYN=1,ACK=1,seq=y,ACKnum=x+1)
	服务器发送确认包(ACK)应答。即SYN标志位和ACK标志位均为1。服务器选择自己的ISN序列号，放在seq域中，同时将确认序列号(ACKnum)设置为客户端的ISN加1，即x+1
	**发送完毕后服务器进入SYN_RCVD状态**
3. 第三次握手：客户端再次发送确认(ACK)包(SYN=0，ACK=1，ACKNum = y+1)
	SYN置为1，ACK标志为1，并把服务器发来的ACK序号字段加1，放在字段中发送给对方，并且在数据段写ISN加一
	**发送完毕后客户端进入ESTABLISH状态，当服务器接收到这个包的时候也进入ESTABLISH阶段，这个时候握手结束**

示意图如下:
![](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png)

### 四次挥手

假设是客户端发送第一次挥手

1. 第一次挥手：客户端和服务器均可以发起(FIN=1,seq=x)
	发送FIN=1表示客户端已经没有数据可以发送了，但是仍可以接收数据
	**发送完毕后，客户端进入FIN_WAIT_1阶段**
2. 第二次挥手：(ACK=1,ACKNum = x+1)
	服务器确认客户端的FIN包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没准备好关闭连接。
	**发送完毕后，服务器进入CLOST_WAIT阶段，客户端接收到这个报文之后进入FIN_WAIT_2状态，表示等待服务器关闭连接**
3. 第三次挥手：(FIN=1,seq=y)
	服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。
	**发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。**
4. 第四次挥手：(ACK=1,ACKNum=y+1)
	客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包.
	**服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。**
	**客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态**
![](https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png)

### 状态自动机
![](http://dl2.iteye.com/upload/attachment/0035/2766/2c25f9fd-10af-3a97-a230-614a65805c43.png)

## 在浏览器中输入网址后执行的全部过程

1. 客户端浏览器通过DNS解析到`www.baidu.com`的IP地址为`220.181.2.2`,通过这个IP地址找到客户端到服务器的路径。客户端向浏览器发起一个HTTP会话到解析出来的IP,通过TCP进行封装数据包输入到网络层
2. 在客户端的传输层：，把HTTP的会话请求分为报文段，添加源端口和目的端口，如果服务器使用80来监听客户端的请求，客户端随机选取一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端
3. 客户端的网络层：不用关心应用层或者传输层的东西，主要是通过查找路由表来确定如何到达服务器，期间可能经过多个路由器。
4. 客户端的链路层：包通过链路层发送到路由器，通过邻居协议查找IP地址的MAC地址，然后发送ARP请求查找目的地址，得到回应后就可以进行传输了，发送IP数据包